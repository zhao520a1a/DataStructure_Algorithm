       
##### 复杂度分析  (算法学习的精髓)

###### 时间复杂度
大O表示法： 
该理论的前提： 所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比
 ![Image](courseware/大O表示法的基础.png)   
 
重点记忆：大O时间复杂度 并不表示代码真正的执行时间，而是代码执行时间随数据规模增长的变化趋势，故又名 渐进时间复杂度，简称时间复杂度。
因此当n很大时，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略！

分析一段代码的时间复杂度，有三个实用的方法：
1. 只关注循环执行次数最多的一段代码
2. 加法法则： 总复杂度 = 量级最大的那段代码的复杂度
3. 乘法法则： 嵌套代码的复杂度 = 嵌套内外代码复杂度的乘积

注：只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。因为当n无限大时就可忽略。
> 重点记忆：时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量

  
###### 复杂度量级
 ![Image](courseware/复杂度量级.jpg)  
 ![Image](courseware/各数量级函数比较.jpg)  

粗略地分为两类，多项式量级和非多项式量级。
   非多项式量级只有2个：O(2^n)和O（n!）
 
###### 空间复杂度
空间复杂度全称就是渐进空间复杂度表示算法的存储空间与数据规模之间的增长关系。
重点记忆：这里所说的存储空间是解决问题时额外申请的空间，不包含存储基础数据空间；
             
             
##### 划分复杂度
>只有同一块代码在不同的情况下，时间复杂度有量级的差距，才有必要区分最好、最坏、平均复杂度。
###### 最好情况时间复杂度
>在最理想的情况下，执行这段代码的时间复杂度。 
###### 最坏情况时间复杂度
>在最糟糕的情况下，执行这段代码的时间复杂度。
###### 平均情况时间复杂度

Sum(每种情况下执行的次数)/ n种情况
注:
计算总执行次数时，应把每种情况发生的概率也考虑进去；
因此我们需要找出所有的输入情况及相应的发生概率，然后再计算加权平均值（又名期望值），所以平均时间复杂度的全称应该叫**加权平均时间复杂**或者**期望时间复杂度**。

 
##### 均摊时间复杂度
> 相应的分析方法：分析方法，摊还分析（又名平摊分析）

针对某种特殊场景的复杂度分析，我们并不需要使用平均复杂度分析的方法，而是采用一种更加简单的分析方法：摊还分析法，所得出来的复杂就叫 均摊时间复杂度；
简单总结一下摊还分析的应用场景：
- 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，
- 并且这些操作之间存在前后连贯的时序关系

这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。
> 小技巧：在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。
总结：个人认为，均摊时间复杂度就是一种特殊的平均时间复杂度，没必要花太多精力去区分它们！
 

 
 

 

 
 

 


             
                 
 
 

 










    